### 并发

**线程安全问题**在多线程环境下，多个线程同时访问共享资源时，可能会导致程序出现意外的行为或错误的结果。这些问题通常与共享资源的状态不一致有关，例如数据的丢失、重复、错误计算等。

线程安全的核心问题在于：**多个线程对共享资源的访问缺乏适当的同步机制** ，从而导致数据竞争（Data Race）和不一致的状态。

仅操作局部变量的方法是线程安全的 ，因为局部变量存储在每个线程的栈内存中，彼此隔离。如果**局部变量引用了堆内存中的对象**（如数组、集合或其他可变对象），则需要特别注意是否有多线程对该对象进行并发访问和修改。

**资源获取即初始化**（RAII，Resouce Acquisition Is Initialization）的设计模式，是指在一个对象的构造函数中获得资源，并在该对象的析构函数中释放它。C++ 中析构函数由系统自动调用，可以自动地隐式释放所获取的资源。Java 对象没有析构函数，Java System 提供了 GC 来管理内存资源，使用 `finalize()` 方法可以将对象标记为可回收的，但是 `finalize()` 标记的对象由 GC 异步地在某个恰当时机回收，所以不能使用 `finalize()` 实现 C++ 中的 RAII。通常使用 Java 提供的 `finally` 语句块：

```java
MyResource res = null; 
try {
    res = new MyResource();
    // Use the resource 
} finally {
    //At exit point, close the resource.
    if (res != null) { res.close(); }
}
```

**区域锁**（Scoped Lock），是指线程进入一个区域时，将自动获取锁，当该线程离开这个区域时，锁将被自动释放。

Java 对于区域锁模式在语言层面上做了封装， 即 `synchronized` 关键字，它保证线程进入该区域后获得对象锁，不管最终该函数从哪里退出，该对象锁都会被正确释放。

**条件变量**（Condition Variables），通常被一个线程用于使自己等待，直到一个涉及共享数据的条件表达式到达特定的状态。当另外的协作线程只是共享数据的状态已经变化，调度器就唤醒在该条件变量上挂起的线程。被唤醒的线程重新对它的条件表达式进行求值，如果共享数据已经满足条件就恢复处理。

Java 的 `Object` 类提供了 `wait/notify/notifyAll` 方法来实现条件变量。

#### Monitor Object设计模式概述

并发编程中，经常要设计这样的对象，该对象的方法在多线程环境下被调用，这些方法的执行会改变该对象本身的状态。为了防止**竞争条件**（Race Condition）的出现，需要考虑以下问题：

- 任何时间，公共的成员方法只能被唯一的线程执行
- 对于对象调用者来说，如果总是需要方法调用前拿锁，方法调用后释放锁，编程比较困难。合理的设计是，对象本身确保对它方法的请求的同步透明的执行，而不需要调用者特殊处理。
- 如果一个线程在对象的方法执行中，由于某些条件不能满足而阻塞，应该允许其它客户端线程的方法调用可以访问该对象。

被客户线程并发访问的对象为**监视器对象**（monitor object），为了防止陷入竞争条件，任一时刻只能有一个同步方法被执行。每个监视器对象包含一个**监视器锁**（monitor lock），被同步方法用于串行访问对象的行为和状态。同步方法可以根据一个或多个与监视器对象相关的监视器条件（monitor condition）来决定何时挂起或恢复执行。

Java Object 类本身就是监视器对象，Java 对并发模式做了内建的支持。