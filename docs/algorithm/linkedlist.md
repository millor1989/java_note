### 链表

#### 1、链表结构

与数组不同，链表不需要连续的存储空间，它通过“指针”将一组零散的内存块串联起来使用，其中内存块称为链表的“结点”。

![img](/assets/d5d5bee4be28326ba3c28373808a62cd.jpg)

与数组相同，链表也支持数据的查找、插入和删除操作。

链表的结构很多，常见的三种结构是：单链表、双向链表和循环链表。

##### 1.1、单链表

单链表（singly-linked list）的结点除了存储数据之外，还记录了链上下一个结点的地址。记录下一个节点地址的指针称为**后继指针**。

![img](/assets/b93e7ade9bb927baad1348d9a806ddeb.jpg)

单链表的第一个结点叫作**头结点**，最后一个结点叫作**尾结点**。头结点用来记录链表的基地址。尾结点的指针不是指向下一个结点而是指向一个空地址NULL，表示这是链表的最后一个结点。

在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。对单链表的插入和删除操作，只需要相邻结点的指针改变，所以对应的时间复杂度是 O(1)。

因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。

Java 代码实现单链表定义：

```java
// Definition for singly-linked list.
public class SinglyListNode {
    int val;
    SinglyListNode next;
    SinglyListNode(int x) { val = x; }
}
```

大多情况下，可以用头结点表示整个链表。

##### 1.2、循环链表

与单链表唯一的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。

![img](/assets/86cb7dc331ea958b0a108b911f38d155.jpg)

和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的[约瑟夫问题](https://zhuanlan.zhihu.com/p/35487124)。

##### 1.3、双向链表

单向链表只有一个方向，结点只有一个后继指针指向后面的结点。而双向链表，每个结点有一个后继指针指向后面的结点，还有一个前驱指针指向前面的结点。

![img](/assets/cbc8ab20276e2f9312030c313a9ef70b.jpg)

双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表**占用更多的内存空间**。

双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，这样的特点，也使双向链表**在某些情况下的插入、删除等操作都要比单链表简单、高效**。

链表中删除数据的两种情况：

1. 删除结点中“值等于某个给定值”的结点；
2. 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始依次遍历，然后再通过指针操作将其删除。尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。

对于第二种情况，已经知道了要删除的结点的地址，但是删除某个结点需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，还是要从头结点开始遍历链表，直到找到前驱结点。对于双向链表来说，它已经保存了前驱结点的指针。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就可以。

同理，希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度完成，而单向链表需要 O(n) 的时间复杂度。

除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，可以通过记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

Java 中的 `LinkedHashMap` 这个容器就用到了双向链表这种数据结构。

双向链表其实用到了**用空间换时间**的设计思想。当内存空间充足的时候，如果更加追求代码的执行速度，就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，就要反过来用时间换空间的设计思路。

软件开发中常用的**缓存**实际上就是利用了空间换时间的设计思想。

##### 1.4、双向循环链表

![img](/assets/d1665043b283ecdf79b157cfc9e5ed91.jpg)

#### 2、链表和数组性能比较

![img](/assets/4f63e92598ec2551069a0eef69db7168.jpg)

数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制（*CPU 在从内存读取数据的时候，会先把读取到的数据加载到 CPU 的缓存中。而 CPU 每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到 CPU 缓存中，然后下次访问内存数据的时候就会先从 CPU 缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是 CPU 缓存存在的意义:为了弥补内存访问速度过慢与 CPU 执行速度快之间的差异*），预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，支持动态扩容。

除此之外，如果代码对内存的使用非常苛刻，那数组就更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

#### 3、LRU 缓存淘汰策略

常见的缓存淘汰策略：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

单链表实现 LRU 策略的思路：

1. 维护一个单链表，越靠近尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。
2. 如果此数据之前已经存在链表中了，那么遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再将其插入到链表的头部。
3. 如果此数据没有在链表中并且缓存未满，则将数据插入缓存，将此结点直接插入到链表的头部。
4. 如果此数据没有在链表中并且缓存已满，则将链表尾结点删除，数据插入缓存，将心的数据结点插入链表的头部。

这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。因为不管缓存有没有满，都需要遍历链表。

实际上，可以继续优化这个实现，比如引入散列表（Hash table）来记录每个数据的位置，可将缓存访问的时间复杂度降到 O(1)。

#### 4、判断单链表存储的字符串是否为回文

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
      return true;
    }

    /*
     * 两个指针，从链表头开始，遍历链表
     */
    // 前一个结点缓存
    ListNode prev = null;
    // 慢指针
    ListNode slow = head;
    // 快指针
    ListNode fast = head;

    /*
     * while 循环找出中间结点
     */
    while (fast != null && fast.next != null) {
      // 快指针前进两步并更新快指针
      fast = fast.next.next;
      // 慢指针前进一步
      ListNode next = slow.next;
      // 慢指针指向之前的结点（对慢指针进行反向处理）
      slow.next = prev;
      // 更新前一个结点缓存
      prev = slow;
      // 更新慢指针
      slow = next;
    }

    // 如果跳出 while 循环时 fast == null，则链表有偶数个元素

    /*
     * 如果跳出 while 循环时快指针不是null，
     * 但是快指针的下一个（next）是null，即当前快指针已经在尾结点
     * 链表有奇数个元素
     */
    if (fast != null) {
      // 慢指针，往后移动一步，刚好位于正中节点
      slow = slow.next;
    }
    

    while (slow != null) {
      if (slow.val != prev.val) {
        return false;
      }
      // 此时slow指针，在往链表后走
      slow = slow.next;
      // prev则相当于往链表前走
      prev = prev.next;
    }

    return true;
  }
}
```

#### 5、掌握链表的关键

##### 5.1、指针（引用）

C 语言中有“指针”（pointer）的概念，而 Java、Python 等语言中与指针类似的概念是“引用”（reference）。它们的意思是相同的，都是所知对象的内存地址。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

##### 5.2、警惕指针丢失和内存泄露

以单链表的插入操作为例，在结点 a 和相邻的结点 b 之间插入结点 x：

![img](/assets/05a4a3b57502968930d517c934347c6e.jpg)

如果按照如下编码，就会发生指针丢失和内存泄露：

```c
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // （本应）将x的结点的next指针指向b结点；
```

本该将 `x->next = b`，但是错误的将 p 的指针赋值给了 x 的指针，相当于 x 指向了 x 自己。从而，结点 b 往后的所有结点都无法访问到了。

C 语言中，内存管理是程序员自己负责的，如果没有手动释放内存，就会产生内存泄露。将上面两行代码互换一下顺序便可以解决内存泄露的问题。

删除链表节点时，也要记得手动释放内存。

对于像 Java 这种虚拟机自动管理内存的编程语言来说，不用考虑内存泄露的问题。

##### 5.3、利用哨兵简化实现难度

结点 p 后面插入一个新的结点：

```c
new_node->next = p->next;
p->next = new_node;
```

要向一个空链表中插入第一个结点：

```c
if (head == null) {
  head = new_node;
}
```

单链表结点删除操作：

```c
p->next = p->next->next;
```

删除链表中的最后一个结点：

```
if (tail->next == null) {
   tail = null;
}
```

可以看出，针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。

此处可以引入“哨兵”来解决边界问题。

引入哨兵结点——`head = null`。不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。

![img](/assets/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

以数组元素查找为例：

```c
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
int find(char* a, int n, char key) {
  // 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
  if(a == null || n <= 0) {
    return -1;
  }
  
  int i = 0;
  // 这里有两个比较操作：i<n和a[i]==key.
  while (i < n) {
    if (a[i] == key) {
      return i;
    }
    ++i;
  }
  
  return -1;
}
```

使用哨兵进行改进：

```c
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
// 我举2个例子，你可以拿例子走一下代码
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
int find(char* a, int n, char key) {
  if(a == null || n <= 0) {
    return -1;
  }
  
  // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }
  
  // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
  char tmp = a[n-1];
  // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
  a[n-1] = key;
  
  int i = 0;
  // while 循环比起代码一，少了i<n这个比较操作
  while (a[i] != key) {
    ++i;
  }
  
  // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
  a[n-1] = tmp;
  
  if (i == n-1) {
    // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
    return -1;
  } else {
    // 否则，返回i，就是等于key值的元素的下标
    return i;
  }
}
```

`a` 很长的时候，比如几万、几十万，哪段代码运行得更快点呢？答案是第二段代码，因为两段代码中执行次数最多就是 `while` 循环那一部分。第二段代码中，通过一个哨兵 `a[n-1] = key`，成功省掉了一个比较语句 `i < n`，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。

这里只是为了举例说明哨兵的作用，实际写代码的时候基本用不着写第二段那样的代码，因为可读性太差了。大部分情况下，并不需要如此追求极致的性能。

##### 5.4、重点留意边界条件处理

软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。

检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

针对不同的场景，可能还有特定的边界条件。

##### 5.5、举例、画图，辅助思考

通过列举例子、画图来帮助思考

##### 5.6、重点掌握 5 个链表操作

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点