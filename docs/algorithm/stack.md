### 栈

放入数据的时候从下往上依次放入，不能在中间插入，取数据时从上往下依次取，不能从中间抽取；后进先出，先进后出，这就是典型的栈结构。

![img](/assets/3e20cca032c25168d3cc605fa7a53a0b.jpg)

从栈的操作上看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。

#### 1、栈的实现

栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈为**顺序栈**，用链表实现的栈为**链式栈**。

数组实现栈的 Java 代码：

```java
// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           //栈的大小

  // 初始化数组，申请一个大小为n的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回false，入栈失败。
    if (count == n) return false;
    // 将item放到下标为count的位置，并且count加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回null
    if (count == 0) return null;
    // 返回下标为count-1的数组元素，并且栈中元素个数count减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```

不管是顺序栈还是链式栈，存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。注意，这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。所以**提到空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。**

不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。

##### 1.1、支持动态扩容的顺序栈

上面代码实现的基于数组的栈，是一个固定大小的栈，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储 next 指针，内存消耗相对较多。

要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。

![img](/assets/b193adf5db4356d8ab35a1d32142b3da.jpg)

对于支持动态扩容的栈，其出栈操作不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度是 O(1)。但是，对于入栈操作来说，当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。所以，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。可以用摊还分析法，进一步分析平均情况下的时间复杂度，为了分析方便，先做一些假设和定义：

- 栈空间不足时，申请一个为原来大小两倍的数组；
- 为了简化，假设只有入栈操作，没有出栈操作；
- 定义不涉及内存搬移的入站操作为 simple-push 操作，时间复杂度为 O(1)。

如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。

![img](/assets/c936a39ad54a9fdf526e805dc18cf6bb.jpg)

可以看出，K 次入栈操作总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。

#### 2、栈的应用

##### 2.1、函数调用栈

栈的经典应用场景就是**函数调用栈**。

操作系统给每个线程分配了一块被组织成“栈”这种结构的独立的内存空间， 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

```java
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
```

`main()` 函数调用了 `add()` 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值。

在执行到 add() 函数时，函数调用栈的情况如图：

![img](/assets/17b6c6711e8d60b61d65fb0df5559a1c.jpg)

其实，不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。 从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。 **最重要的是因为只能操作"栈顶元素"**，在作用域的角度看，操作完一个作用域的再回到之前的作用域下，用栈保存临时变量则是最好的选择，其他的数组，链表等都能"违规地"进行随机访问。

##### 2.2、表达式求值

栈的另一个应用场景，编译器利用栈实现**表达式求值**。

编译器是通过两个栈来实现表达式求值的，其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

下图展示了 `3+5*8-6` 这个表达式的计算过程：

![img](/assets/bc77c8d33375750f1700eb7778551600.jpg)

##### 2.3、表达式括号匹配检查

可以借助栈来检查表达式中的括号是否匹配。

用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

##### 2.4、浏览器前进、后退

使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。当后退之后，打开了新的页面，新的页面入栈 X，此时无法通过前进、后退查看后退之前的页面了，需要清空栈 Y。

#### 3、JVM 中的“堆栈”与栈

堆是堆、栈是栈、堆栈是栈！！

JVM 堆栈难道是中文翻译造的陷阱？？

每个 JVM 线程都有一个私有的 JVM stack，与线程同时创建。JVM stack 保存着 frames（栈帧）。JVM stack 与 C 语言的 stack 类似：保存着局部变量（local variables）和部分结果（partial results），并且在方法的调用和返回中起着作用。因为除了 push 和 pop 栈帧之外，从不直接操作 JVM stack，栈帧可能被分配在 heap 上。JVM stack 的内存不必是连续的。