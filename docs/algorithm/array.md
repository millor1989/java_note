### 数组

数组是最基础的数据结构，几乎每种编程语言中都有数组这种数据类型。

数组（Array）是一种**线性表数据结构**，用一组连续的内存空间，来存储一组具有相同类型的数据。

#### 1、数组特性

##### 1.1、线性表

线性表（Linear List），数据排列像一条线一样的结构。这种数据结构每个元素最多只有前和后两个方向，并且存在一个唯一的没有前驱的数据元素（头），并存在一个唯一的没有后继的元素（尾）。除了数组，**链表、队列、栈等也是线性表结构**。

![img](/assets/b6b71ec46935130dff5c4b62cf273477.jpg)

与线性表对应的概念是非线性表，比如二叉树、堆、图等。非线性表中，数据之间不是简单的前后关系。

![img](/assets/6ebf42641b5f98f912d36f6bf86f6569.jpg)

##### 1.2、连续存储空间

计算机在分配内存空间的时候，每一份内存空间都会对应一个内存地址，连续的内存空间对应的是连续的内存地址，计算机通过内存地址可以访问内存中的值。

##### 1.3、相同的数据类型

数据类型相同，换句话说时数据存储占用的内存空间大小是一样的。

基于这些特性，数组是**可随机访问**的。

##### 1.4、随机访问

存取第 n 个元素时，不需要访问前 n-1 个元素。

以长度为 10 的 int 类型数组为例。计算机位数组 a 分配了一块连续的存储空间 1000 ~ 1039（每个 int 元素占用空间为 4），内存块的首地址为 base_address = 1000。

![img](/assets/98df8e702b14096e7ee4a5141260cdc4.jpg)

第 i 个元素的内存地址 `a[i]_address`，数据类型占用空间 `data_type_size`，则有以下公式：

```
a[i]_address = base_address + i * data_type_size
```

数组的起始下标为 0，一定程度上避免了根据下标访问元素时通过减 1 来计算元素地址，提高了一点效率（下标从 0 开始很可能也只是一种编程语言发展的惯例）。

根据下标对数组进行随机访问的时间复杂度为 O(1)，对于排序好的数组，进行二分查找，时间复杂度为 O(log n)。笼统地讲数组查找时间复杂度为 O(1) 是错误的。

#### 2、插入和删除

数组为了保持内存空间的连续性，插入、删除操作比较低效。

##### 2.1、插入

假设数组的长度为 n，现在，如果要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置空出来给新来的数据，要将第 k～n 这部分的元素都顺序地往后挪一位。

如果在数组的末尾插入元素，那就不需要移动数据了，时间复杂度为 O(1)。但如果在数组的开头插入元素，所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+...n)/n=O(n)。

如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。

如果数组中存储的数据并没有顺序要求，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。

![img](/assets/3f70b4ad9069ec568a2caaddc231b7dc.jpg)

这种情况下，用这种方法在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。

##### 2.2、删除

与插入数据类似，如果要删除第 k 个位置的数据，为了内存的连续性，也需要移动数据。如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

在某些特殊场景下，并非要追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率会提高。

![img](/assets/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)

可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据移动。这正是 JVM 标记清除垃圾回收算法的核心思想。