### 抽象工厂模式

Abstract Factory

抽象工厂模式，是一种创建型设计模式，能创建一系列相关的对象，而无需指定具体类。

抽象工厂模式建议为系列中的每件产品明确声明接口——抽象产品类型。然后，确保所有的产品变体都继承这些接口。还需要声明抽象工厂接口——声明构造所有产品的方法，这些方法必须返回抽象产品类型。然后，基于抽象工厂接口创建不同的工厂类，每个工厂类只能返回特定类别的产品。客户端代码可以通过相应的抽象工厂接口调用具体工厂实现和产品类。无需修改客户端代码，就能更改传递给客户端的工厂类，也能更改客户端代码接受的产品变体。

#### 抽象工厂模式结构

![抽象工厂设计模式](/assets/abstract_factory_structure.png)

**抽象产品** （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。**具体产品** （Concrete Product） 是抽象产品的多种不同类型实现。 

**抽象工厂** （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。**具体工厂** （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。

尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的 *抽象* 产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 **客户端** （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。

#### 适用场景：

- 需要与不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于扩展性的考虑（不基于产品的具体类型进行构建），可以使用抽象工厂模式
- 如果有一个基于一组抽象方法的类，且其主要功能因此变得不明确，也可以考虑使用抽象工厂模式。

#### 优缺点

**优点**：

- 可以确保同一工厂生成的产品是相关的（相互匹配的）
- 可以避免客户端和具体产品代码的耦合
- 单一职责原则——产品生成代码在同一个位置，代码易于维护
- 开闭原则——向应用程序中引入新产品变体时，无需修改客户端代码

**缺点**：

由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂